"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var _ = require("lodash");
var geometry_1 = require("./geometry");
var constants_1 = require("./constants");
var classnames_1 = require("classnames");
var adjust_1 = require("./adjust");
var compareConnections = function (a) { return function (b) { return a.port === b.port && a.nodeId === b.nodeId; }; };
var EndpointImpl = (function () {
    function EndpointImpl() {
    }
    EndpointImpl.computeId = function (nodeId, connectionId, kind) {
        return nodeId + "_" + connectionId + "_" + kind;
    };
    EndpointImpl.computeIdIn = function (conn) {
        return conn.nodeId + "_" + conn.port + "_" + conn.kind;
    };
    EndpointImpl.extractEndpointInfo = function (id) {
        var regex = /(.+)_(\d+)_(input|output)/g;
        var match = regex.exec(id);
        if (match === null)
            throw Error("Illegal id string " + id);
        return { nodeId: match[1], port: parseInt(match[2]), kind: match[3] };
    };
    return EndpointImpl;
}());
function computeConnectionId(input, output) {
    return EndpointImpl.computeIdIn(input) + "__" + EndpointImpl.computeIdIn(output);
}
function extractConnectionFromId(id) {
    var sepIndex = id.indexOf('__');
    var inputId = id.substr(0, sepIndex);
    var outputId = id.substr(sepIndex + 2);
    return { input: EndpointImpl.extractEndpointInfo(inputId), output: EndpointImpl.extractEndpointInfo(outputId) };
}
function isEmptyArrayOrUndefined(obj) {
    return obj === undefined || (Array.isArray(obj) && obj.length === 0);
}
var nodeIdPredicate = function (connection) { return function (node) { return Array.isArray(connection) ? connection.findIndex(function (conn) { return conn.nodeId === node.id; }) >= 0 : node.id === connection.nodeId; }; };
var epPredicate = function (nodeId, port) { return function (ep) {
    var comp = function (testee) { return (port === undefined || testee.port === port) && testee.nodeId === nodeId; };
    return Array.isArray(ep.connection) ? ep.connection.findIndex(comp) >= 0 : comp(ep.connection);
}; };
function filterIfArray(input, predicate) {
    if (input instanceof Array)
        return input.find(predicate);
    else
        return input;
}
var Editor = (function (_super) {
    __extends(Editor, _super);
    function Editor(props) {
        var _this = _super.call(this, props) || this;
        _this.endpointCache = new Map();
        _this.state = _this.initialState();
        window.onCreateNode = _this.createNewNode.bind(_this);
        window.onStartCreatingNewNode = _this.onStartCreatingNewNode.bind(_this);
        return _this;
    }
    Editor.prototype.initialState = function () {
        var e_1, _a, e_2, _b;
        var props = this.props;
        var nodesState = new Map();
        var connectionState = new Map();
        var margin = { x: 100, y: 100 };
        var usedPlace = [];
        try {
            for (var _c = __values(props.nodes), _d = _c.next(); !_d.done; _d = _c.next()) {
                var node = _d.value;
                if (nodesState.has(node.id)) {
                    console.warn("No state found for node " + node.id);
                    continue;
                }
                var pos = node.position || { x: 10 + margin.x, y: 10 + margin.y };
                try {
                    for (var usedPlace_1 = __values(usedPlace), usedPlace_1_1 = usedPlace_1.next(); !usedPlace_1_1.done; usedPlace_1_1 = usedPlace_1.next()) {
                        var place = usedPlace_1_1.value;
                        if (place.hit(pos))
                            pos.x = place.right + margin.x;
                        pos.y = place.top;
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (usedPlace_1_1 && !usedPlace_1_1.done && (_b = usedPlace_1.return)) _b.call(usedPlace_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                var size = { x: 100, y: 100 };
                nodesState.set(node.id, { pos: pos, size: size, isCollapsed: false });
                usedPlace.push(new geometry_1.Rect(pos, size));
                for (var k in node.inputs) {
                    var i = parseInt(k);
                    var inputPos = { x: pos.x, y: pos.y + 100 + i * 100 };
                    var key = EndpointImpl.computeId(node.id, i, 'input');
                    connectionState.set(key, inputPos);
                }
                for (var k in node.outputs) {
                    var i = parseInt(k);
                    var outputPos = { x: pos.x + size.x, y: pos.y + 100 + i * 100 };
                    var key = EndpointImpl.computeId(node.id, i, 'output');
                    connectionState.set(key, outputPos);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var transformation = { dx: 0, dy: 0, zoom: 1 };
        var componentSize = { width: 800, height: 600 };
        return { nodesState: nodesState, connectionState: connectionState, transformation: transformation, componentSize: componentSize };
    };
    Editor.prototype.select = function (type, id) {
        if (!this.state.selection || this.state.selection.id !== id) {
            this.setState(function (state) {
                return __assign({}, state, { selection: { id: id, type: type } });
            });
        }
    };
    Editor.prototype.toggleExpandNode = function (id) {
        var _this = this;
        var node = this.props.nodes.find(function (n) { return n.id === id; });
        var desiredState = node.isCollapsed !== undefined ? !node.isCollapsed : !this.state.nodesState.get(id).isCollapsed;
        var updateState = function () {
            return _this.setState(function (state) {
                state.nodesState.get(id).isCollapsed = desiredState;
                return __assign({}, state);
            });
        };
        var config = this.props.config;
        if (config.onChanged)
            config.onChanged({ type: 'NodeCollapseChanged', id: id, shouldBeCollapsed: desiredState }, updateState);
        if (config.onChanged === undefined || config.demoMode)
            updateState();
    };
    Editor.prototype.onDragStarted = function (id, e) {
        if (e.button === constants_1.BUTTON_LEFT)
            this.currentAction = { lastPos: { x: e.clientX, y: e.clientY }, id: id, type: 'node' };
    };
    Editor.prototype.onDragEnded = function (e) {
        this.currentAction = undefined;
        this.setState(function (state) { return (__assign({}, state, { workingItem: undefined })); });
    };
    Editor.prototype.onDrag = function (e) {
        var _this = this;
        if (this.currentAction === undefined)
            return;
        var newPos = { x: e.clientX, y: e.clientY };
        var _a = geometry_1.Vector2d.subtract(newPos, this.currentAction.lastPos), dx = _a.x, dy = _a.y;
        this.setState(function (state) {
            if (_this.currentAction.type === 'node') {
                state.nodesState.get(_this.currentAction.id).pos.x += dx;
                state.nodesState.get(_this.currentAction.id).pos.y += dy;
                return __assign({}, state);
            }
            else if (_this.currentAction.type === 'connection') {
                var endpoint = _this.currentAction.endpoint;
                var free = geometry_1.Vector2d.subtract(newPos, _this.editorBoundingRect);
                var key = EndpointImpl.computeId(endpoint.nodeId, endpoint.port, endpoint.kind);
                var offset = _this.state.connectionState.get(key);
                var node = _this.state.nodesState.get(endpoint.nodeId);
                var fixed = geometry_1.Vector2d.add(offset, node.pos);
                if (endpoint.kind === 'input') {
                    var workingItem = { type: 'connection', input: fixed, output: free };
                    return __assign({}, state, { workingItem: workingItem });
                }
                else if (endpoint.kind === 'output') {
                    var workingItem = { type: 'connection', input: free, output: fixed };
                    return __assign({}, state, { workingItem: workingItem });
                }
            }
            else if (_this.currentAction.type === 'translate') {
                var pt = _this.state.transformation;
                var transformation_1 = { dx: pt.dx + dx, dy: pt.dy + dy, zoom: pt.zoom };
                _this.setState(function (state) { return (__assign({}, state, { transformation: transformation_1 })); });
            }
        });
        this.currentAction.lastPos = newPos;
    };
    Editor.prototype.onCreateConnectionStarted = function (endpoint, e) {
        e.stopPropagation();
        this.currentAction = { lastPos: { x: e.screenX, y: e.screenY }, endpoint: endpoint, type: 'connection' };
    };
    Editor.prototype.onCreateConnectionEnded = function (endpoint, e) {
        if (this.currentAction && this.currentAction.type === 'connection') {
            if (this.currentAction.endpoint.kind === 'input') {
                this.createConnection(this.currentAction.endpoint, endpoint);
            }
            else if (this.currentAction.endpoint.kind === 'output') {
                this.createConnection(endpoint, this.currentAction.endpoint);
            }
        }
    };
    Editor.prototype.removeFromArrayOrValue = function (value, toRemove) {
        var e_3, _a;
        if (!Array.isArray(value))
            return undefined;
        if (Array.isArray(toRemove)) {
            try {
                for (var toRemove_1 = __values(toRemove), toRemove_1_1 = toRemove_1.next(); !toRemove_1_1.done; toRemove_1_1 = toRemove_1.next()) {
                    var it = toRemove_1_1.value;
                    var index = value.findIndex(compareConnections(it));
                    if (index < 0)
                        return value;
                    value.splice(index, 1);
                    return value;
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (toRemove_1_1 && !toRemove_1_1.done && (_a = toRemove_1.return)) _a.call(toRemove_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
        else {
            var index = value.findIndex(compareConnections(toRemove));
            if (index < 0)
                return value;
            value.splice(index, 1);
            return value;
        }
    };
    Editor.prototype.removeConnection = function (input, output) {
        var nodes = this.props.nodes;
        var inputNode = nodes.find(function (node) { return node.id === input.nodeId; });
        var outputNode = nodes.find(function (node) { return node.id === output.nodeId; });
        inputNode.inputs[input.port].connection =
            this.removeFromArrayOrValue(inputNode.inputs[input.port].connection, { nodeId: output.nodeId, port: output.port });
        outputNode.outputs[output.port].connection =
            this.removeFromArrayOrValue(outputNode.outputs[output.port].connection, { nodeId: input.nodeId, port: input.port });
    };
    Editor.prototype.createConnection = function (input, output) {
        var _this = this;
        var _a = this.props, nodes = _a.nodes, config = _a.config;
        var inputNode = nodes.find(function (node) { return node.id === input.nodeId; });
        var outputNode = nodes.find(function (node) { return node.id === output.nodeId; });
        var isArrayOrUndefined = function (variable) {
            return variable === undefined || Array.isArray(variable);
        };
        if (input.kind === output.kind) {
            return;
        }
        if (!isArrayOrUndefined(inputNode.inputs[input.port].connection) || !isArrayOrUndefined(outputNode.outputs[output.port].connection)) {
            return;
        }
        if (config.connectionValidator && !config.connectionValidator(output, input)) {
            return;
        }
        var updateProps = function () {
            var outputConnection = { nodeId: outputNode.id, port: output.port };
            if (Array.isArray(inputNode.inputs[input.port].connection))
                inputNode.inputs[input.port].connection.push(outputConnection);
            else
                inputNode.inputs[input.port].connection = outputConnection;
            var inputConnection = { nodeId: inputNode.id, port: input.port };
            if (Array.isArray(outputNode.outputs[output.port].connection))
                outputNode.outputs[output.port].connection.push(inputConnection);
            else
                outputNode.outputs[output.port].connection = inputConnection;
            _this.setState(function (state) { return state; });
        };
        if (config.onChanged !== undefined) {
            config.onChanged({ type: 'ConnectionCreated', input: input, output: output }, updateProps);
        }
        if (config.demoMode || config.onChanged === undefined) {
            updateProps();
        }
    };
    Editor.prototype.onKeyDown = function (e) {
        var _this = this;
        var e_4, _a, e_5, _b, e_6, _c, e_7, _d, e_8, _e, e_9, _f;
        var selection = this.state.selection;
        if (e.keyCode === constants_1.KEY_CODE_DELETE) {
            if (selection) {
                var config = this.props.config;
                if (selection.type === 'connection') {
                    var _g = extractConnectionFromId(selection.id), input_1 = _g.input, output_1 = _g.output;
                    var updateProps = function () { _this.removeConnection(input_1, output_1); };
                    if (config.onChanged !== undefined)
                        config.onChanged({ input: input_1, output: output_1, type: 'ConnectionRemoved', id: selection.id }, updateProps);
                    if (config.onChanged === undefined || config.demoMode)
                        updateProps();
                }
                else if (selection.type === 'node') {
                    var index_1 = this.props.nodes.findIndex(function (node) { return node.id === selection.id; });
                    var correspondingConnections_1 = [];
                    var nodeToDelete_1 = this.props.nodes[index_1];
                    var inputIndex = -1;
                    try {
                        for (var _h = __values(nodeToDelete_1.inputs), _j = _h.next(); !_j.done; _j = _h.next()) {
                            var input = _j.value;
                            ++inputIndex;
                            if (isEmptyArrayOrUndefined(input.connection))
                                continue;
                            var peerNodes = this.props.nodes.filter(nodeIdPredicate(input.connection));
                            try {
                                for (var peerNodes_1 = __values(peerNodes), peerNodes_1_1 = peerNodes_1.next(); !peerNodes_1_1.done; peerNodes_1_1 = peerNodes_1.next()) {
                                    var peerNode = peerNodes_1_1.value;
                                    var peerOutputsIds = peerNode.outputs
                                        .map(function (v, i) { return ({ v: v, i: i }); })
                                        .filter(function (o) { return epPredicate(nodeToDelete_1.id)(o.v); })
                                        .map(function (o) { return o.i; });
                                    try {
                                        for (var peerOutputsIds_1 = __values(peerOutputsIds), peerOutputsIds_1_1 = peerOutputsIds_1.next(); !peerOutputsIds_1_1.done; peerOutputsIds_1_1 = peerOutputsIds_1.next()) {
                                            var peerOutputId = peerOutputsIds_1_1.value;
                                            correspondingConnections_1.push({
                                                input: { kind: 'input', nodeId: nodeToDelete_1.id, port: inputIndex },
                                                output: { kind: 'output', nodeId: peerNode.id, port: peerOutputId }
                                            });
                                        }
                                    }
                                    catch (e_6_1) { e_6 = { error: e_6_1 }; }
                                    finally {
                                        try {
                                            if (peerOutputsIds_1_1 && !peerOutputsIds_1_1.done && (_c = peerOutputsIds_1.return)) _c.call(peerOutputsIds_1);
                                        }
                                        finally { if (e_6) throw e_6.error; }
                                    }
                                }
                            }
                            catch (e_5_1) { e_5 = { error: e_5_1 }; }
                            finally {
                                try {
                                    if (peerNodes_1_1 && !peerNodes_1_1.done && (_b = peerNodes_1.return)) _b.call(peerNodes_1);
                                }
                                finally { if (e_5) throw e_5.error; }
                            }
                        }
                    }
                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                    finally {
                        try {
                            if (_j && !_j.done && (_a = _h.return)) _a.call(_h);
                        }
                        finally { if (e_4) throw e_4.error; }
                    }
                    var outputIndex = -1;
                    try {
                        for (var _k = __values(nodeToDelete_1.outputs), _l = _k.next(); !_l.done; _l = _k.next()) {
                            var output = _l.value;
                            ++outputIndex;
                            if (isEmptyArrayOrUndefined(output.connection))
                                continue;
                            var peerNodes = this.props.nodes.filter(nodeIdPredicate(output.connection));
                            try {
                                for (var peerNodes_2 = __values(peerNodes), peerNodes_2_1 = peerNodes_2.next(); !peerNodes_2_1.done; peerNodes_2_1 = peerNodes_2.next()) {
                                    var peerNode = peerNodes_2_1.value;
                                    var peerInputsIds = peerNode.inputs
                                        .map(function (v, i) { return ({ v: v, i: i }); })
                                        .filter(function (o) { return epPredicate(nodeToDelete_1.id)(o.v); })
                                        .map(function (o) { return o.i; });
                                    try {
                                        for (var peerInputsIds_1 = __values(peerInputsIds), peerInputsIds_1_1 = peerInputsIds_1.next(); !peerInputsIds_1_1.done; peerInputsIds_1_1 = peerInputsIds_1.next()) {
                                            var peerInputId = peerInputsIds_1_1.value;
                                            correspondingConnections_1.push({
                                                input: { kind: 'input', nodeId: peerNode.id, port: peerInputId },
                                                output: { kind: 'output', nodeId: nodeToDelete_1.id, port: outputIndex }
                                            });
                                        }
                                    }
                                    catch (e_9_1) { e_9 = { error: e_9_1 }; }
                                    finally {
                                        try {
                                            if (peerInputsIds_1_1 && !peerInputsIds_1_1.done && (_f = peerInputsIds_1.return)) _f.call(peerInputsIds_1);
                                        }
                                        finally { if (e_9) throw e_9.error; }
                                    }
                                }
                            }
                            catch (e_8_1) { e_8 = { error: e_8_1 }; }
                            finally {
                                try {
                                    if (peerNodes_2_1 && !peerNodes_2_1.done && (_e = peerNodes_2.return)) _e.call(peerNodes_2);
                                }
                                finally { if (e_8) throw e_8.error; }
                            }
                        }
                    }
                    catch (e_7_1) { e_7 = { error: e_7_1 }; }
                    finally {
                        try {
                            if (_l && !_l.done && (_d = _k.return)) _d.call(_k);
                        }
                        finally { if (e_7) throw e_7.error; }
                    }
                    var updateProps = function () {
                        var e_10, _a;
                        try {
                            for (var correspondingConnections_2 = __values(correspondingConnections_1), correspondingConnections_2_1 = correspondingConnections_2.next(); !correspondingConnections_2_1.done; correspondingConnections_2_1 = correspondingConnections_2.next()) {
                                var connectionToDelete = correspondingConnections_2_1.value;
                                _this.removeConnection(connectionToDelete.input, connectionToDelete.output);
                            }
                        }
                        catch (e_10_1) { e_10 = { error: e_10_1 }; }
                        finally {
                            try {
                                if (correspondingConnections_2_1 && !correspondingConnections_2_1.done && (_a = correspondingConnections_2.return)) _a.call(correspondingConnections_2);
                            }
                            finally { if (e_10) throw e_10.error; }
                        }
                        _this.props.nodes.splice(index_1, 1);
                    };
                    if (config.onChanged !== undefined)
                        config.onChanged({ type: 'NodeRemoved', id: selection.id, correspondingConnections: correspondingConnections_1 }, updateProps);
                    if (config.onChanged === undefined || config.demoMode)
                        updateProps();
                }
                this.setState(function (state) {
                    return __assign({}, state, { selection: undefined });
                });
            }
        }
    };
    Editor.prototype.onMouseGlobalDown = function (e) {
        if (e.button === constants_1.BUTTON_MIDDLE) {
            this.currentAction = { type: 'translate', lastPos: { x: e.clientX, y: e.clientY } };
        }
        else if (e.button === constants_1.BUTTON_LEFT) {
            this.setState(function (state) {
                return __assign({}, state, { selection: undefined });
            });
        }
    };
    Editor.prototype.onWheel = function (e) {
        if (e.ctrlKey)
            return;
        if (this.props.config.disableZoom)
            return;
        var pt = this.state.transformation;
        var zoomFactor = Math.pow(1.25, Math.sign(e.deltaY));
        var zoom = pt.zoom * zoomFactor;
        var cx = e.clientX;
        var cy = e.clientY;
        var dy = cy * (pt.zoom - zoom) + pt.dy;
        var dx = cx * (pt.zoom - zoom) + pt.dx;
        var transformation = { dx: dx, dy: dy, zoom: zoom };
        this.setState(function (state) { return (__assign({}, state, { transformation: transformation })); });
    };
    Editor.prototype.setConnectionEndpoint = function (conn, element) {
        var _this = this;
        if (!element)
            return;
        var parentPos = this.state.nodesState.get(conn.nodeId).pos;
        var key = EndpointImpl.computeId(conn.nodeId, conn.port, conn.kind);
        var cached = this.endpointCache.get(key);
        var newDomRect = element.getBoundingClientRect();
        var globalOffset = this.editorBoundingRect || { x: 0, y: 0 };
        var offset = {
            x: Math.floor(newDomRect.x + newDomRect.width / 2 - parentPos.x - globalOffset.x),
            y: Math.floor(newDomRect.y + newDomRect.height / 2 - parentPos.y - globalOffset.y)
        };
        if (cached === undefined || !geometry_1.Vector2d.compare(offset, cached)) {
            this.endpointCache.set(key, offset);
            setImmediate(function () {
                return _this.setState(function (state) {
                    state.connectionState.set(key, offset);
                    return state;
                });
            });
        }
    };
    Editor.prototype.updateEditorSize = function (element) {
        var _this = this;
        if (element === null)
            return;
        var width = Math.floor(element.width.baseVal.value);
        var height = Math.floor(element.height.baseVal.value);
        if (width < 1 || height < 1)
            return;
        if (this.state.componentSize.width !== width || this.state.componentSize.height !== height)
            setImmediate(function () { return _this.setState(function (state) { return (__assign({}, state, { componentSize: { height: height, width: width } })); }); });
    };
    Editor.prototype.connection = function (outputConn, inputConn) {
        var _a = this.state, nodesState = _a.nodesState, connectionState = _a.connectionState;
        var inputKey = EndpointImpl.computeId(inputConn.nodeId, inputConn.port, inputConn.kind);
        var outputKey = EndpointImpl.computeId(outputConn.nodeId, outputConn.port, outputConn.kind);
        var key = outputKey + "_" + inputKey;
        var connId = computeConnectionId(inputConn, outputConn);
        var isSelected = this.state.selection && this.state.selection.id === connId;
        if (!connectionState.has(inputKey)) {
            return '';
        }
        if (!connectionState.has(outputKey)) {
            return '';
        }
        var outputOffset = connectionState.get(outputKey);
        var inputOffset = connectionState.get(inputKey);
        var outputNode = nodesState.get(outputConn.nodeId);
        var inputNode = nodesState.get(inputConn.nodeId);
        var output = geometry_1.Vector2d.add(outputOffset, outputNode.pos);
        var input = geometry_1.Vector2d.add(inputOffset, inputNode.pos);
        var additionalClassNames = __spread((outputConn.additionalClassName || []), (inputConn.additionalClassName || []));
        var notes = outputConn.notes || inputConn.notes || undefined;
        return this.connectionPath(output, input, additionalClassNames, notes, isSelected, key, this.select.bind(this, 'connection', connId));
    };
    Editor.prototype.connectionPath = function (output, input, additionalClassNames, notes, selected, key, onClick) {
        var _a;
        var props = this.props;
        var classNameOrDefault = function (label) {
            if (props.config.style && props.config.style[label])
                return props.config.style[label];
            return label;
        };
        var a0 = output;
        var a3 = input;
        var anchorLength = props.config.connectionAnchorsLength || 100;
        var dir = props.config.direction || 'we';
        var dx = Math.max(Math.abs(a0.x - a3.x) / 1.5, anchorLength) * (dir === 'we' ? 1 : -1);
        var a1 = { x: a0.x - dx, y: a0.y };
        var a2 = { x: a3.x + dx, y: a3.y };
        var cmd;
        if (props.config.connectionType === 'bezier')
            cmd = "M " + a0.x + " " + a0.y + " C " + a1.x + " " + a1.y + ", " + a2.x + " " + a2.y + ", " + a3.x + " " + a3.y;
        else if (props.config.connectionType === 'linear')
            cmd = "M " + a0.x + " " + a0.y + " L " + a3.x + " " + a3.y;
        var width = 3 * this.state.transformation.zoom;
        var pathClassNames = classnames_1.default(classNameOrDefault('connection'), (_a = {}, _a[classNameOrDefault('selected')] = selected, _a), additionalClassNames || []);
        if (notes)
            return React.createElement("path", { className: pathClassNames, onClick: onClick ? onClick : function () { }, key: key || 'wk', strokeWidth: width + "px", d: cmd },
                React.createElement("title", null, notes));
        else
            return React.createElement("path", { className: pathClassNames, onClick: onClick ? onClick : function () { }, key: key || 'wk', strokeWidth: width + "px", d: cmd });
    };
    Editor.prototype.onEditorUpdate = function (element) {
        if (element === null)
            return;
        var rect = element.getBoundingClientRect();
        if (this.editorBoundingRect === undefined ||
            this.editorBoundingRect.x !== rect.x ||
            this.editorBoundingRect.y !== rect.y) {
            this.editorBoundingRect = rect;
            this.setState(function (state) { return state; });
        }
    };
    Editor.prototype.render = function () {
        var _this = this;
        var e_11, _a, e_12, _b;
        var workingConnection = function (info) {
            return _this.connectionPath(info.output, info.input);
        };
        var classNameOrDefault = function (label) {
            if (props.config.style && props.config.style[label])
                return props.config.style[label];
            return label;
        };
        var _c = this, props = _c.props, state = _c.state;
        var nodeStyle = function (pos) { return ({
            top: pos.y + "px",
            left: pos.x + "px",
        }); };
        var dir = this.props.config.direction || 'we';
        var dirMapping = dir === 'we' ? { 'input': 'right', 'output': 'left' } : { 'input': 'left', 'output': 'right' };
        var properties = function (node) {
            if (node.properties !== undefined && node.properties.display === 'only-dots') {
                var dot = function (kind, total) {
                    return function (prop, index) {
                        var conn = { nodeId: node.id, port: index, kind: kind, name: prop.name };
                        var site = dirMapping[kind];
                        var style = site === 'right' ? { right: '7px' } : {};
                        var dotClassName = classnames_1.default(classNameOrDefault('dot'), classNameOrDefault(kind), classNameOrDefault(site));
                        return (React.createElement("div", { key: EndpointImpl.computeId(node.id, index, kind) },
                            React.createElement("div", { onMouseDown: _this.onCreateConnectionStarted.bind(_this, conn), onMouseUp: _this.onCreateConnectionEnded.bind(_this, conn), ref: _this.setConnectionEndpoint.bind(_this, conn), className: dotClassName, style: __assign({}, style, { position: 'absolute', top: "calc(" + 100 * (index + 1) / (total + 1) + "% - 8px)" }), title: prop.name })));
                    };
                };
                return __spread(node.inputs.map(dot('input', node.inputs.length)), node.outputs.map(dot('output', node.outputs.length)));
            }
            else {
                var dotClassName_1 = function (conn) { return classnames_1.default(classNameOrDefault('dot'), classNameOrDefault(conn.kind), classNameOrDefault(dirMapping[conn.kind])); };
                var dot_1 = function (conn, name) {
                    return React.createElement("div", { onMouseDown: _this.onCreateConnectionStarted.bind(_this, conn), onMouseUp: _this.onCreateConnectionEnded.bind(_this, conn), ref: _this.setConnectionEndpoint.bind(_this, conn), className: dotClassName_1(conn), title: name });
                };
                var mapProp = function (kind) { return function (prop, index) {
                    var key = EndpointImpl.computeId(node.id, index, kind);
                    return (React.createElement("div", { key: key },
                        prop.renderer ? prop.renderer(prop) : prop.name,
                        dot_1({ nodeId: node.id, port: index, kind: kind, name: prop.name }, prop.name)));
                }; };
                return __spread(node.inputs.map(mapProp('input')), node.outputs.map(mapProp('output')));
            }
        };
        var collapsedProperties = function (node) {
            var dot = function (conn, key, index, size, name) {
                var style = function () {
                    var radius = 20;
                    var angle = size === 1 ? 0 : (index - size / 2 + 0.5) * Math.PI / 4;
                    if (dirMapping[conn.kind] === 'right') {
                        var center = { x: -20, y: 1 };
                        return {
                            top: center.y + radius * Math.sin(angle) + "px",
                            left: center.x + radius * Math.cos(angle) + "px"
                        };
                    }
                    else if (dirMapping[conn.kind] === 'left') {
                        var center = { x: 0, y: 1 };
                        return {
                            top: center.y + radius * Math.sin(angle) + "px",
                            left: center.x - radius * Math.cos(angle) + "px"
                        };
                    }
                    else {
                        console.warn("Unknown dir " + conn.kind);
                    }
                };
                var dotClassName = classnames_1.default(classNameOrDefault('dot'), classNameOrDefault(conn.kind), classNameOrDefault(dirMapping[conn.kind]));
                return React.createElement("div", { style: style(), key: key, onMouseDown: _this.onCreateConnectionStarted.bind(_this, conn), onMouseUp: _this.onCreateConnectionEnded.bind(_this, conn), ref: _this.setConnectionEndpoint.bind(_this, conn), className: dotClassName, title: name });
            };
            var mapProp = function (kind, size) { return function (prop, i) {
                var key = EndpointImpl.computeId(node.id, i, kind);
                return dot({ nodeId: node.id, port: i, kind: kind, name: prop.name }, key, i, size, prop.name);
            }; };
            var inputsClassNames = classnames_1.default(classNameOrDefault('connections'), classNameOrDefault(dirMapping['input']));
            var outputsClassNames = classnames_1.default(classNameOrDefault('connections'), classNameOrDefault(dirMapping['output']));
            var inputs = React.createElement("div", { key: node.id + 'inputs', className: inputsClassNames }, node.inputs.map(mapProp('input', node.inputs.length)));
            var outputs = React.createElement("div", { key: node.id + 'outputs', className: outputsClassNames }, node.outputs.map(mapProp('output', node.outputs.length)));
            return [inputs, outputs];
        };
        var newNodes = adjust_1.adjust(state.nodesState, state.componentSize, props.nodes);
        newNodes.forEach(function (value, key) { return state.nodesState.set(key, value); });
        var nodes = props.nodes.map(function (node) {
            var _a, _b;
            var nodeState = state.nodesState.get(node.id);
            var isCollapsed = node.isCollapsed !== undefined ? node.isCollapsed : nodeState.isCollapsed;
            var isSelected = _this.state.selection && _this.state.selection.id === node.id;
            var nodeClassNames = classnames_1.default(classNameOrDefault('node'), (_a = {},
                _a[classNameOrDefault('collapsed')] = isCollapsed,
                _a[classNameOrDefault('selected')] = isSelected,
                _a), node.classNames || []);
            var headerClassNames = classNameOrDefault('header');
            var expanderClassNames = classNameOrDefault('expander');
            var iconClassNames = classnames_1.default(classNameOrDefault('icon'), (_b = {},
                _b[classNameOrDefault('arrow-down')] = isCollapsed,
                _b[classNameOrDefault('arrow-right')] = !isCollapsed,
                _b));
            var bodyClassNames = classNameOrDefault('body');
            return (React.createElement("div", { onClick: _this.select.bind(_this, 'node', node.id), key: node.id, style: nodeStyle(nodeState.pos), className: nodeClassNames },
                React.createElement("div", { onMouseDown: _this.onDragStarted.bind(_this, node.id), onDoubleClick: _this.toggleExpandNode.bind(_this, node.id), className: headerClassNames },
                    React.createElement("div", { className: expanderClassNames, onClick: _this.toggleExpandNode.bind(_this, node.id), onMouseDown: function (e) { return e.stopPropagation(); } },
                        React.createElement("div", { className: iconClassNames })),
                    React.createElement("span", null, node.name),
                    isCollapsed ? collapsedProperties(node) : ''),
                isCollapsed ? '' : React.createElement("div", { className: bodyClassNames },
                    props.config.resolver(node),
                    properties(node))));
        });
        var connections = [];
        var nodeDict = new Map();
        try {
            for (var _d = __values(props.nodes), _e = _d.next(); !_e.done; _e = _d.next()) {
                var node = _e.value;
                nodeDict.set(node.id, node);
            }
        }
        catch (e_11_1) { e_11 = { error: e_11_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            }
            finally { if (e_11) throw e_11.error; }
        }
        var _loop_1 = function (node) {
            var e_13, _a;
            var i = 0;
            var _loop_2 = function (input) {
                var e_14, _a;
                if (input.connection === undefined)
                    return "continue";
                if (Array.isArray(input.connection)) {
                    try {
                        for (var _b = __values(input.connection), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var connection = _c.value;
                            var opponentNode = nodeDict.get(connection.nodeId);
                            if (opponentNode === undefined)
                                continue;
                            var oppConnectionRaw = opponentNode.outputs[connection.port].connection;
                            var oppConnection = filterIfArray(oppConnectionRaw, function (c) { return c.nodeId === node.id; });
                            var inputConn = {
                                nodeId: node.id,
                                port: i,
                                kind: 'input',
                                additionalClassName: connection.classNames,
                                notes: connection.notes
                            };
                            var outputConn = {
                                nodeId: connection.nodeId,
                                port: connection.port,
                                kind: 'output',
                                additionalClassName: oppConnection.classNames,
                                notes: oppConnection.notes
                            };
                            connections.push({ in: inputConn, out: outputConn });
                        }
                    }
                    catch (e_14_1) { e_14 = { error: e_14_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_14) throw e_14.error; }
                    }
                }
                else {
                    var connection_1 = input.connection;
                    var opponentNode = nodeDict.get(connection_1.nodeId);
                    if (opponentNode === undefined)
                        return "continue";
                    var oppConnectionRaw = opponentNode.outputs[connection_1.port].connection;
                    var oppConnection = filterIfArray(oppConnectionRaw, function (c) { return c.nodeId === node.id; });
                    if (props.nodes.findIndex(function (n) { return n.id === connection_1.nodeId; }) < 0)
                        return "continue";
                    var inputConn = {
                        nodeId: node.id,
                        port: i,
                        kind: 'input',
                        additionalClassName: connection_1.classNames,
                        notes: connection_1.notes
                    };
                    var outputConn = {
                        nodeId: input.connection.nodeId,
                        port: input.connection.port,
                        kind: 'output',
                        additionalClassName: oppConnection.classNames,
                        notes: oppConnection.notes
                    };
                    connections.push({ in: inputConn, out: outputConn });
                }
                ++i;
            };
            try {
                for (var _b = __values(node.inputs), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var input = _c.value;
                    _loop_2(input);
                }
            }
            catch (e_13_1) { e_13 = { error: e_13_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_13) throw e_13.error; }
            }
        };
        try {
            for (var _f = __values(props.nodes), _g = _f.next(); !_g.done; _g = _f.next()) {
                var node = _g.value;
                _loop_1(node);
            }
        }
        catch (e_12_1) { e_12 = { error: e_12_1 }; }
        finally {
            try {
                if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
            }
            finally { if (e_12) throw e_12.error; }
        }
        var connectionsLines = connections.map(function (conn) { return _this.connection(conn.out, conn.in); });
        var workingItem = state.workingItem && state.workingItem.type === 'connection' ? workingConnection(state.workingItem) : '';
        var transformation = state.transformation;
        var grid = function () {
            if (props.config.grid === false)
                return '';
            var dy = 18;
            var dx = 18;
            if (props.config.grid !== null && typeof props.config.grid === 'object') {
                dx = props.config.grid.size || 18;
                dy = props.config.grid.size || 18;
            }
            var _a = state.componentSize, width = _a.width, height = _a.height;
            var draw = function (element) {
                if (element === null)
                    return;
                if (_this.gridSize !== undefined && (_this.gridSize.height === height && _this.gridSize.width === width))
                    return;
                _this.gridSize = { height: height, width: width };
                var ctx = element.getContext('2d');
                ctx.clearRect(0, 0, element.width, element.height);
                ctx.beginPath();
                ctx.strokeStyle = '#f2f2f2';
                for (var iy = 0; iy < height / dy; ++iy) {
                    var y = dy * (iy + 0.5);
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                }
                for (var ix = 0; ix < width / dx; ++ix) {
                    var x = dx * (ix + 0.5);
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                }
                ctx.stroke();
            };
            var gridClassName = classNameOrDefault('grid');
            return React.createElement("canvas", { className: gridClassName, width: width, height: height, ref: draw.bind(_this) });
        };
        var nodesContainerStyle = {
            transform: "matrix(" + transformation.zoom + ",0,0," + transformation.zoom + "," + transformation.dx + "," + transformation.dy + ")"
        };
        var editorClassName = classnames_1.default(classNameOrDefault('react-flow-editor'), props.additionalClassName || []);
        return (React.createElement("div", { style: props.style, ref: this.onEditorUpdate.bind(this), tabIndex: 0, onKeyDown: this.onKeyDown.bind(this), onWheel: this.onWheel.bind(this), onMouseLeave: this.onDragEnded.bind(this), onMouseMove: this.onDrag.bind(this), onMouseDown: this.onMouseGlobalDown.bind(this), onMouseUp: this.onDragEnded.bind(this), className: editorClassName },
            grid(),
            React.createElement("svg", { ref: this.updateEditorSize.bind(this), className: classNameOrDefault('connections'), xmlns: "http://www.w3.org/2000/svg" },
                connectionsLines,
                workingItem),
            React.createElement("div", { style: nodesContainerStyle }, nodes)));
    };
    Editor.prototype.createNewNode = function (name, factory, pos) {
        var _this = this;
        var isInRange = function (min, size, value) {
            return min <= value && (min + size) >= value;
        };
        if (isInRange(this.editorBoundingRect.x, this.editorBoundingRect.width, pos.x) &&
            isInRange(this.editorBoundingRect.y, this.editorBoundingRect.height, pos.y)) {
        }
        else {
            return;
        }
        pos.x -= this.editorBoundingRect.x;
        pos.y -= this.editorBoundingRect.y;
        var createHash = function () {
            var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
            var LENGTH = 6;
            return _.times(LENGTH)
                .map(function () { return Math.floor(Math.random() * chars.length); })
                .map(function (i) { return chars.charAt(i); })
                .reduce(function (p, c) { return p + c; }, '');
        };
        var proto = factory();
        var id = proto.type + "_" + createHash();
        var config = this.props.config;
        var updateProps = function () {
            _this.props.nodes.push(__assign({}, proto, { id: id }));
            _this.setState(function (state) {
                state.nodesState.set(id, { isCollapsed: true, pos: pos, size: { x: 100, y: 100 } });
                return __assign({}, state);
            });
        };
        if (config.onChanged !== undefined) {
            this.state.nodesState.set(id, { isCollapsed: true, pos: pos, size: { x: 100, y: 100 } });
            config.onChanged({ type: 'NodeCreated', node: __assign({}, proto, { id: id }) }, updateProps);
        }
        if (config.demoMode || config.onChanged === undefined) {
            updateProps();
        }
    };
    Editor.prototype.onStartCreatingNewNode = function (name, factory, pos, offset, additionalClassNames) {
        var _this = this;
        var classNameOrDefault = function (label) {
            if (_this.props.config.style && _this.props.config.style[label])
                return _this.props.config.style[label];
            return label;
        };
        var node = document.createElement('div');
        node.className = classnames_1.default(classNameOrDefault('node'), classNameOrDefault('collapsed'), additionalClassNames || []);
        node.style.top = pos.y + "px";
        node.style.left = pos.x + "px";
        node.style.position = 'absolute';
        var title = document.createElement('span');
        title.innerHTML = name;
        var header = document.createElement('div');
        header.className = classNameOrDefault('header');
        header.appendChild(title);
        node.appendChild(header);
        var host = document.createElement('div');
        host.className = classNameOrDefault('react-flow-creating-node');
        host.appendChild(node);
        document.body.appendChild(host);
        var onFinishCreatingNewNode = function () {
            var nodeRect = node.getBoundingClientRect();
            document.body.removeChild(host);
            document.body.removeEventListener('mouseup', onFinishCreatingNewNode);
            document.body.removeEventListener('mouseleave', onFinishCreatingNewNode);
            document.body.removeEventListener('mousemove', onMove);
            _this.createNewNode(name, factory, geometry_1.Vector2d.floor({ x: nodeRect.left, y: nodeRect.top }));
        };
        var onMove = function (e) {
            node.style.left = e.x - offset.x + "px";
            node.style.top = e.y - offset.y + "px";
        };
        document.body.addEventListener('mouseup', onFinishCreatingNewNode);
        document.body.addEventListener('mouseleave', onFinishCreatingNewNode);
        document.body.addEventListener('mousemove', onMove);
    };
    Editor.prototype.getPositions = function () {
        var e_15, _a;
        var map = new Map();
        try {
            for (var _b = __values(this.state.nodesState.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), key = _d[0], entry = _d[1];
                map.set(key, entry.pos);
            }
        }
        catch (e_15_1) { e_15 = { error: e_15_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_15) throw e_15.error; }
        }
        return map;
    };
    return Editor;
}(React.Component));
exports.Editor = Editor;
//# sourceMappingURL=editor.js.map